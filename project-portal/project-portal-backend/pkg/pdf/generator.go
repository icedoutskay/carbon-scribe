// Package pdf provides PDF generation utilities for CarbonScribe document types.
// It wraps jung-kurt/gofpdf and exposes a simple template-based API.
package pdf

import (
	"bytes"
	"fmt"
	"time"

	"github.com/jung-kurt/gofpdf"
)

// WatermarkText controls the diagonal stamp placed on every page.
type WatermarkText string

const (
	WatermarkNone         WatermarkText = ""
	WatermarkDraft        WatermarkText = "DRAFT"
	WatermarkConfidential WatermarkText = "CONFIDENTIAL"
	WatermarkApproved     WatermarkText = "APPROVED"
)

// GenerateRequest carries everything needed to produce a PDF.
type GenerateRequest struct {
	TemplateID string // "PDD" | "MONITORING_REPORT" | "VERIFICATION_CERTIFICATE"
	ProjectID  string
	Data       map[string]interface{}
	Watermark  WatermarkText
}

// Generate produces a PDF byte slice from the identified template and data.
func Generate(req GenerateRequest) ([]byte, error) {
	tmpl, ok := Templates[req.TemplateID]
	if !ok {
		return nil, fmt.Errorf("unknown template_id: %q (valid: PDD, MONITORING_REPORT, VERIFICATION_CERTIFICATE)", req.TemplateID)
	}
	return tmpl.Render(req)
}

// --- low-level helpers shared by all templates ---

// newDoc creates a standard A4 PDF with our default font and margins.
func newDoc() *gofpdf.Fpdf {
	pdf := gofpdf.New("P", "mm", "A4", "")
	pdf.SetMargins(20, 20, 20)
	pdf.SetAutoPageBreak(true, 20)
	// Core font (no external font files needed)
	pdf.AddPage()
	return pdf
}

// drawHeader writes the CarbonScribe logo text + document title banner.
func drawHeader(pdf *gofpdf.Fpdf, title, subtitle string) {
	// Top bar
	pdf.SetFillColor(34, 85, 56) // forest green
	pdf.Rect(0, 0, 210, 18, "F")

	pdf.SetTextColor(255, 255, 255)
	pdf.SetFont("Helvetica", "B", 14)
	pdf.SetXY(20, 4)
	pdf.CellFormat(170, 10, "CarbonScribe  |  "+title, "", 0, "L", false, 0, "")

	// Reset
	pdf.SetTextColor(40, 40, 40)
	pdf.SetXY(20, 24)

	// Subtitle / document type label
	pdf.SetFont("Helvetica", "I", 10)
	pdf.CellFormat(170, 7, subtitle, "", 1, "L", false, 0, "")
	pdf.Ln(4)
}

// drawSectionTitle writes a styled section heading.
func drawSectionTitle(pdf *gofpdf.Fpdf, title string) {
	pdf.SetFont("Helvetica", "B", 11)
	pdf.SetFillColor(235, 245, 238)
	pdf.SetTextColor(34, 85, 56)
	pdf.CellFormat(170, 8, "  "+title, "", 1, "L", true, 0, "")
	pdf.SetTextColor(40, 40, 40)
	pdf.Ln(2)
}

// drawKeyValue renders a label: value row.
func drawKeyValue(pdf *gofpdf.Fpdf, key, value string) {
	pdf.SetFont("Helvetica", "B", 9)
	pdf.CellFormat(55, 7, key+":", "", 0, "L", false, 0, "")
	pdf.SetFont("Helvetica", "", 9)
	pdf.MultiCell(115, 7, value, "", "L", false)
}

// drawBody renders a block of body text.
func drawBody(pdf *gofpdf.Fpdf, text string) {
	pdf.SetFont("Helvetica", "", 10)
	pdf.MultiCell(170, 6, text, "", "L", false)
	pdf.Ln(3)
}

// drawFooter adds a bottom footer with page number and generation date.
func drawFooter(pdf *gofpdf.Fpdf) {
	pdf.SetFooterFunc(func() {
		pdf.SetY(-15)
		pdf.SetFont("Helvetica", "I", 8)
		pdf.SetTextColor(150, 150, 150)
		pdf.CellFormat(0, 10,
			fmt.Sprintf("Generated by CarbonScribe  |  %s  |  Page %d",
				time.Now().UTC().Format("2006-01-02"),
				pdf.PageNo()),
			"", 0, "C", false, 0, "")
	})
}

// addWatermark burns a diagonal watermark text on top of all current pages.
func addWatermark(pdf *gofpdf.Fpdf, text WatermarkText) {
	if text == WatermarkNone {
		return
	}
	pageCount := pdf.PageNo()
	for i := 1; i <= pageCount; i++ {
		pdf.SetPage(i)
		pdf.SetFont("Helvetica", "B", 52)
		pdf.SetTextColor(210, 210, 210)
		pdf.TransformBegin()
		// Rotate 45Â° around the centre of the page (A4: 105, 149 mm)
		pdf.TransformRotate(45, 105, 149)
		pdf.SetXY(30, 130)
		pdf.CellFormat(150, 20, string(text), "", 0, "C", false, 0, "")
		pdf.TransformEnd()
		pdf.SetTextColor(40, 40, 40)
	}
}

// toBytes serialises the Fpdf to bytes and returns any error.
func toBytes(pdf *gofpdf.Fpdf) ([]byte, error) {
	if err := pdf.Error(); err != nil {
		return nil, fmt.Errorf("pdf rendering error: %w", err)
	}
	var buf bytes.Buffer
	if err := pdf.Output(&buf); err != nil {
		return nil, fmt.Errorf("pdf output error: %w", err)
	}
	return buf.Bytes(), nil
}

// str safely converts an interface{} map value to string.
func str(data map[string]interface{}, key string) string {
	if v, ok := data[key]; ok {
		return fmt.Sprintf("%v", v)
	}
	return ""
}

// strOrDefault returns the value for key or a fallback.
func strOrDefault(data map[string]interface{}, key, fallback string) string {
	s := str(data, key)
	if s == "" {
		return fallback
	}
	return s
}
